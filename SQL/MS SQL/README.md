MS SQL
====================

> 멀티캠퍼스 MS SQL 기본과정<br>
-------
> 2019-02-18

### MS SQL 1일차
인스턴스 : 하나의 시스템에 여러번 SQL Server를 설치할 수 있다. <br>
→ 멀티 인스턴스를 지원한다. <br>
→ 하나의 SQL Server에 데이터베이스는 3만여개 만들 수 있다. <br>

인스턴스 유형
- 기본 인스턴스 : 해당 컴퓨터 이름으로 연결 <br>
- 명명된 인스턴스 : 말그대로 다시 명명된 인스턴스 <br>

Ex) 컴퓨터 이름 : 기본 인스턴스 / 컴퓨터이름\AAA, 컴퓨터이름\BBB : 명명된 인스턴스 <br>

서비스란? <br>
: OS에서 어떠한 기능을 지원하기 위해 동작하는 백그라운드 프로세스를 서비스라고 한다. <br>

SQL Server는 서비스에 의해서 동작한다. <br>

서비스 계정 <br>
: 서비스는 서비스 계정의 바운더리에서 실행된다. <br>

권장 - 관리자 계정과는 별도의 계정을 만들고 서비스 계정으로 등록한다. <br> 

구성관리자(관리도구) <br>
1. 서비스 관리 <br>
2. 프로토콜 관리 <br>

사용자들이 SQL Server에 연결하는 방법 <br>
1. Windows 인증 방법 <br>
: 운영체제에서 인증받은 정보를 통해 SQL Server에 연결한다. <br>
2. SQL Server 인증방법 <br>
: OS 계정과는 별도로 SQL Server 자체 계정을 통해서 연결한다. <br> 

SQL Server에서 설정할 수 있는 보안 모드 <br>
1. Windows 인증 모드 - 위(연결 방법)의 1번만 쓰게 하겠다. <br>

2. 혼합 모드 - 위(연결 방법)의 방법 둘다 쓰게 하겠다. <br>

서비스 <br>
SQL Server 데이터베이스 엔진 : SQL Service의 메인 서비스 <br>
SQL Server 에이전트 : 자동화와 관련된 기능을 지원하는 서비스 <br>
데이터 정렬 설정
: Korean_Wansung_CI_AS(Case In An Sensitive) <br>
CI → 대소문자 구분 안함 <br>
AS → 사전식 정렬 <br>

서비스 일시중지 : 현재 연결된 세션은 유지되지만, 새로운 연결을 허용하지 않는다. <br>


프로토콜의 종류 <br>
1. 로컬 프로토콜 : 해당 시스템 내에서만 연결 가능한 프로토콜
2. 네트워크 프로토콜 : 다른 시스템에 연결할 수 있는 프로토콜

SQL Server 프로토콜 <br>
1. 공유 메모리 - 로콜 프로토콜 
2. <b>TCP/IP</b> - 네트워크 프로토콜
3. 명명된 파이프 - 이전버전 호환성

로그인 : SQL Server에 연결하기 위한 계정 <br>

트랜잭션 : 데이터베이스에서 논리적인 작업의 처리 단위 <br>

- 데이터 저장소 모델 <br>
OLTP(Online Transaction Proceesing) <br>
OLAP(Online Analytical Processing) <br>
데이터 웨어하우스(Data Warehouese) <br>

- 데이터베이스 구분 <br>
1. 시스템 데이터베이스 : SQL Server의 운영과 관련된 정보들이 저장되는 데이터베이스 <br>
2. 사용자 데이터베이스 : 관리자가 생성하여 업무적 데이터를 저장하는 데이터베이스 <br>

- 시스템 데이터 베이스
1. MASTER : SQL Server 운영에 필요한 모든 정보들을 저장한다. <br>
2. MODEL : 모든 데이터베이스들의 원형이다. <br>
3. MSDB : 자동화 관련 정보를 저장한다. <br>
4. TEMPDB : 임시 작업을 처리하기 위해서 사용되는 공간 <br> 

- 데이터베이스 구조 <br>
1. 데이터베이스는 최소한 하나 이상의 데이터 파일과 최소한 하나 이상의 로그 파일로 구성된다. <br>

데이터의 사이즈가 데이터베이스의 사이즈가 된다. <br>

페이지(8KB) : 물리적으로 데이터를 저장하는 단위 <br>

DATA <br>
- 주 데이터 파일(.mdf) <br>
- 보조 데이터파일(.ndf) <br>

LOG 파일 (.ldf) <br>

데이터 파일은 파일그룹(기본 - Primary)에 소속된다. <br>
- 첫 번째 데이터파일( 주 데이터 파일)은 기본적으로(무조건) Primary 파일 그룹에 소속된다. <br>
- 그 이후에 데이터 파일들(보조 데이터)은 임의로 파일 그룹을 지정할 수 있다. <br>

파일그룹을 사용하는 이유? → 대용량 데이터베이스 솔루션이다.<br>
1. 테이블들의 특정 위치를 지정할 수 있다. <br>
2. 파일 그룹 단위로 백업과 복원을 할 수 있다. <br>
3. 테이블과 인덱스를 분리할 수 있다. <br>
4. 분할된 테이블과 인덱스를 만들 수 있다. <br>

로그인과 사용자 <br>
: SQL Server에 연결하기 위한 계정을 로그인 이라하고 데이터베이스에 연결하기 위한 계정을 사용자라고 한다. <br>

스키마 => 방 <br>
SQL 2005 객체 전체 이름 <br>
개체들의 전체 이름 : 서버명, 데이터베이스명, 스키마명, 개체명  <br>

-------
> 2019-02-19

### MS SQL 2일차 
모델과 다이어그램 <br>
: 모델을 통해서 얻어진 결과물을 다이어그램이라고 한다. 

#### 예전
개념적 모델링 <br>
- 목적 : 업무를 일반화 시킨다. (누구나 다 알기 쉬운 형태로 표현한다.) <br>
- ER-Model을 통해서 ER-Diagram을 만든다. <br>
- 데이터 관련 항목들을 정의한다. <br>
- 결과물 : ER-Diagram <br>

논리적 데이터 모델링 <br>
1. 매핑룰 : 개념적 데이터 모델링 단계에서 얻어진 ER-Diagram을 관계형 데이터베이스 이론에 맞게 변환시키는 작업 <br>
2. 완벽한 정규화 : 가장 효율적으로 데이터가 저장될 수 있는 구조를 만든다. <br>
- 결과물 : 정규화된 스키마 <br>


물리적 데이터 모델링 : 특정 DBMS에 최적화된 설계 단계 <br>
1. 데이터 사용량 분석과 사용자들의 프로세스 분석 <br>
2. 역정규화 : 퍼포먼스 향상 <br>
3. 데이터베이스 내의 개체들 생성 <br> 

업무 프로세스 모델링 <br>
목적 : 업무를 일반화 시킨다. (누구나 다 알기 쉬운 형태로 표현한다.) <br>
결과물 : BPMN 다이어그램 <br>

#### 현재
개념적 데이터 모델링 <br>
: 데이터 관련 항목들을 정의한다. <br>
- 결과물 : 관계 스키마 <br>
- 예전에는 업무를 공유하기 위해서 했는데 이젠 필요없다. <br>
- 그냥 바로 테이블 구조 만들면 되며, 업무 프로세스 모델링으로 커뮤니케이션 하면 됨. <br>

논리적 데이터 모델링 <br>
1. 완벽한 정규화 : 가장 효율적으로 데이터가 저장될 수 있는 구조를 만든다. <br>
- 결과물 : 정규화된 스키마 <br>

물리적 데이터 모델링 : 특정 DBMS에 최적화된 설계 단계 <br>
1. 데이터 사용량 분석과 사용자들의 프로세스 분석 <br>
2. 역정규화 : 퍼포먼스 향상 <br>
3. 데이터베이스 내의 개체들 생성 <br> 

관계형 데이터베이스 정의 <br>
: 관계형 데이터베이스는 가장 작은 논리적 단위인 테이블로 구성되고, 그 테이블에 있는 필드들로 연결된 것이다. <br>
→ 이 두 줄이 관계형 데이터 베이스의 80퍼센트 이상이다! <br>
→ 가장 작은 논리적 단위인 테이블로 구성되어야 하는 이유 : 보다 효율적으로 데이터가 저장될 수 있는 구조를 만들기 위해서 

L자형 테이블 → 가장 잘못된 설계 <br>

관계란? 업무적인 연관성이고, 관계는 두 테이블 사이에서 이루어지며 관계를 맺고 있는 두 테이블 중에 반드시 하나는 부모 테이블이 되고 나머지 하나는 자식 테이블이 된다. (주체 역할) <br>
부모테이블의 기본키는 자식 테이블에 포린키로 전이된다. <br>

정규화를 수행하면 테이블은 가장 작은 논리적 단위로 구성되고, 데이터는 가장 효율적으로 저장될 수 있는 구조가 된다. <br>

정규형 vs 정규화 <br>
: 정규형에 맞게 정규화를 한다. <br>

정규형 <br>
1. 제 1 정규형 <br>
2. 제 2 정규형 <br>
3. 제 3 정규형 <br>
4. B-Code 정규형 → 이론적으로만 <br> 
5. 제 4 정규형 → 이론적으로만 <br>
6. 제 5 정규형 → 이론적으로만 <br>

1. 제 1 정규형 <br>
: **반복되는 속성**이나 그룹 속성들을 제거하고 새로운 실체를 추가한 후에 기존 실체들과 일대다 관계를 맺는다. <br>

2. 제 2 정규형 <br>
: **복합키**로 구성된 경우 복합키 전체에 의존하지 않고, 복합키 일부에만 의존하는 속성들이 존재한다면 이를 제거한다. <br>

3. 제 3 정규형 <br>
: 기본키에 의존하지 않고, 일반 속성에 의존적인 컬럼들을 제거한다. <br>

누가 먼저 데이터로 관리되어야 하는가? <br>
→ 먼저 관리되어야 하는 쪽이 부모 테이블이다. <br>

**정규화 모델 검증하는 방법** <br>
1. **중복되는 데이터**는 없는지 <br>
2. **NULL 값이 입력 될 수 밖에 없는 상황**은 없는지 <br>

논리 모델은 정규화된 모델, 물리 모델은 최적화된 모델 <br>

테이블 분리
1. 레크도 기준으로 테이블 분리 <br>
2. 칼럼을 기준으로 테이블 분리 <br>
1) 사용자들의 프로세스 분석 <br>

-----

스키마 : 데이터베이스의 논리적 구성 <br>
그룹을 사용하는 이유? : 사용자들을 조직화하고, 권한 관리를 단순화 <br>

데이터 형식 : 문자, 숫자, 날짜(비즈니스 데이터 형식)<br>

작은 데이터 형식과 큰 데이터 형식이 연산하게 되면, 결과는 큰 데이터 형식이 된다. <br>

날짜를 검색할 때는 내가 검색하는 날짜보다 크거나 같고, 그 다음날 보다 작게 검색한다. <br>

그래서 보통 날짜는 CHAR(8) '20190224'와 같은 식으로 저장한다. <br>

SQL 2008 <br>
: DATE -> '2019-02-24' 3BYTE 날짜만 지원 <br>
: TIME -> '11:11:11.111' 3BYTE 시간만 지원 <br>

 1) 고정길이 데이터 형식에 NULL값이 입력되면 공간을 차지 한다. <br>
 2) 가변길이 데이터 형식에 NULL값이 입력되면 공간을 차지하지 않는다. <br>
 3) 고정길이 데이터 형식에 NULL값이 입력되더라도 SPARSE 속성이 적용되어 있으면 공간을 차지하지 않는다. <br>

 관계형 데이터베이스 데이터 무결성 3가지
 1. 참조 무결성 : 자식 테이블에 데이터가 입력될 때 부모 테이블의 기본키 열을 참조한다. <br>
 → 부모 테이블에 존재하지 않는 데이터가 자식 테이블에 존재할 수 없도록 강제하겠다. <br>
 → 일반적인 관계에서 CASCADE 옵션을 적용하지 않는다. → 꼭 필요한 경우에만 제한적으로 적용한다. <br>

 참조 무결성이 필요해진 이유? <br>
 : 컬럼을 기준으로 테이블을 분리했기 때문에 <br>

 컬럼을 기준으로 테이블을 분리한 이유? <br>
 : 보다 효율적으로 데이터가 저장될 수 있는 구조를 만들기 위해서 <br>

 2. 실체(엔티티) 무결성 <br>
 : 각각의 row는 상호 구분 가능해야 한다. <br>
 키 : 각각의 레코드를 구분할 수 있는 컬럼 <br>
 
 키의 종류 <br>
 1) 후보 키 : 각각의 레코드를 구분할 수 있는 모든 컬럼. Ex) 사원번호, 주민번호, 핸드폰, 이메일 <br>
 2) 기본 키 : 해당 테이블을 데표할 것, 길이가 짧을 것 Ex) 사원번호 <br>
 3) 대체 키 : 기본키를 대체할 수 있는 컬럼. Ex) 주민번호, 핸드폰, 이메일 <br>
 4) 대리 키 : 기본키가 여러 컬럼이거나, 사이즈가 너무 커서 비효율적인 경우 새로운 컬럼을 추가해서 기본키로 정의한다. <br>

 3. 도메인 무결성
 : 해당 열에 입력될 수 있는 데이터 타입, 값의 범위, 경우의 수, 형식 등을 정의해서 잘못된 값이 저장될 수 없도록 강제하겠다. <br>
 1) 데이터 타입 <br>
 2) CHECK 제약조건 → 값의 범위, 경우의 수, 형식 정의 <br>
 3) DEFAULT 제약조건 → 기본값 <br>

-------
> 2019-02-20

### MS SQL 3일차 

한 라인에 대한 주석은 -- <br>
여러 라인에 대한 주석은 / * * / <br>

포린키 컬럼은 NULL값을 허용하는가? <br>
: 포린키 컬럼은 기본적으로 NULL값을 허용한다. <br>
만일 NULL값을 허용하지 않고자 한다면 제약조건 적용할 때 NOT NULL 옵션을 써주어야 한다. <br>

연산자 우선순위 : NOT, AND, OR <br>

#### SELECT 문장 기본
- SELECT / FROM / WHERE <br>
- 연산자 <br>
산술 연산자 <br>
논리 연산자 <br>
비교 연산자 <br>
기타 연산자 <br>
- 데이터 정렬 <br>
- 중복된 행 제거 <br>
- NULL 값 조회 <br>
- 출력 레코드 제한(TOP) <br>
- UNION과 UNION ALL 연산자 <br>
- EXCEPT, INTERSECT 연산자 <br>
- 범위조회(BETWEEN A AND B) <br>
- 목록 조회(IN) <br>
- 유사문자 조회(LIKE) <br>
- 존재 확인(EXISTS) <br>
- CASE 문(단순 CASE문, 검색된 CASE문) <br>

#### 다량의 데이터 처리
- SELECT ~ INTO <br>
- INSERT ~ SELECT <br>
'#' 세션 임시 테이블 : 임시테이블을 만든 세션만 엑세스 할 수 있다. <br>
'##' 전역 일시 테이블 : 다른 세션에서도 엑세스 할 수 있다. <br>

임시 테이블을 사용하는 이유는? <br>
- 조회된 결과를 재사용하기 위해서.. <br>

BCP는 다운로드 & 업로드 가능 - 올드버전 <br>
BULK INSERT 문장은 다운로드는 안되지만 업로드 가능 - 좀더 빠름 <br>

#### DML 활용
- 요약된 결과 집합 조회 - GROUP BY, HAVING 절 <br>
- 내부조인(INNER JOIN) : 양쪽 테이블에서 일치하는 데이터들만 보겠다. <br>
- 외부 조인 <br>
1) 왼쪽 외부조인 <br>
2) 오른쪽 외부조인 <br>
- 전체조인(FULL JOIN) - 의미없다 <br>
- 자체조인(SELF JOIN) - 의미있음! <br>

#### 하위 질의(Sub Query)
- 단순 하위질의 <br>
단순 하위 질의의 특징 <br>
1. 괄호로 묶여진다. <br>
2. 하위 질의만 실행해도 질의가 정상적으로 실행된다. <br>
3. 안쪽 질의가 먼저 실행되고 그 결과가 바깥 질의에 영향을 미친다. <br>
- 상관관계 하위질의 <br>

#### 계층적인 구조
- 재귀적 관계 <br>














