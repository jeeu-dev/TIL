C/C++/자료구조
====================

> 자료 : [패스트캠퍼스 컴퓨터 공학 올인원 패키지](https://www.fastcampus.co.kr/dev_online_cs/)
> 
> 수강 사이트 : https://online.fastcampus.co.kr
-------
> 2019-02-28

#### 0강 - 인트로

1. C언어 기초 문법
2. 자료구조 시초 및 심화이론 

#### 1강 - 프로그래밍 개발환경 구축하기
소스 코드부터 실행파일까지
: 설계도 →(에디터)→ 소스코드 →(전처리기)→ 향상된 소스코드 → (컴파일러) → 목적코드 → (링커) → 실행파일 

#### 2강 - 변수와 상수
라이브러리 불러오기

변수의 초기화와 쓰레기 값

1) 정적 변수로 선언된 것은 기본적으로 0으로 초기화

2) 정적 변수가 아닌 수를 0으로 초기화 하려면 값을 일일이 넣어주어야 한다.

변수와 상수

예약어와 식별자

정수의 표현방법
:  부호 절대값 방식 → 부호 비트 - 맨 앞 양수:0 / 음수:1
:  실제로는 2의 보수 방식 사용 - 2의 보수 = 1의 보수(모든 비트 뒤집기) + 1 / 이 때 올림 수가 발생하면 무시

실수의 표현방법
1) 지수부, 유효숫자부 나누어서 표현. 

#### 3강 기본 입출력

`scanf("%d", &a);` → 실제로는 잘 사용하지 않음 / 취약한 함수임

실수형을 입력받아서 소수점 셋째 자리까지 출력하기

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void){
    double a;
    scanf("%lf", &a);
    printf("%.2f\n", a);
    system("pause");
    return 0;
}
```

#### 4강 연산자

`%`  : 모듈러(Modular)연산 - 나머지 구하기, `\"` : 큰따옴표, `\t` : Tab

논리 연산자 `!`: 부정, `&&` : 그리고, `||`: 또는

비트 연산자 `~`: 부정, `&`: 그리고, `|`: 또는, `^`: 배타적, `<<`: 왼쪽 시프트

* 시프트 연산자가 많이 쓰임.

#### 5강 조건문

#### 6강 반복문

#### 7강 함수

재귀함수 - 자기자신을 포함하는 함수, 기본적으로 자기자신을 계속 불러낸다. 반드시 재귀종료 조건이 필요하다.
Ex) 재귀함수를 이용한 팩토리얼

#### 8강 배열

- 배열을 사용하면 동일한 성격의 데이터를 다수 표현할 수 있다.
- 배열의 선언과 초기화 : 자료형 배열명[배열의 크기] = {초기화 값}; *초기화 값은 없을 수도 있음
- `INT_MIN` : 최댓값을 구하기 위해 자주 사용되는 기능, `<limits.h>` 헤더 파일에 정의가 되어있는 것으로 int형 범위의 최솟값을 반환. `INT_MAX` 또한 사용 가능
- c언어는 기본적으로 자체적인 문자열 자료형 제공하지 않음. c언어에서는 문자를 여러 개 묶어 놓는 형태로 문자열 표현, c++에서는 이러한 불편함을 알고 있기 때문에 자체적으로 String 자료형 제공.

#### 9강 포인터

- 메모리 주소를 저장한다.
  → 포인터는 특정한 변수 자체가 존재하는 메모리 주소의 값을 가진다.

  ```c
  int a = 5; // a의 값 : 5 | 주소 : 0xAFB03954
  
  int *b = &a; // b의 값 : 0xAFB03954 | 주소 : 0xCA29839F
  ```

  - 주소 연산자(&) : 변수 앞에 붙어서 변수의 메모리 시작 주소 값을 반환
  - 포인터(*) : 포인터변수를 선언할 때 사용
  - 간접참조 연산자(*) : 선언된 포인터 변수가 가리키는 변수를 구한다

- 포인터는 컴퓨터 시스템의 특정한 메모리에 바로 접근할 수 있습니다.

- **따라서 기존에 존재하던 중요한 메모리 영역에 접근하지 않도록 해야 합니다.**

- 다음과 같은 코드는 굉장히 위험한 코드입니다.

  ```c
  int *a =0x33484735;
  *a = 0;
  ```

> 2019-03-07

#### 10강 - 문자

- C 언어의 문자는 아스키 코드를 따른다.
- 아스키 코드는 0~127 중의 1바이트로 구성되며 주요 문자를 출력하도록 해준다.
- 문자열을 처리할 때 버퍼의 개념이 많이 사용됩니다.
  - 버퍼(Buffer)란 임시적으로 특정한 데이터를 저장하기 위한 목적으로 사용됩니다.
  - C언어는 기본적으로 사용자가 의도하지 않아도 자동으로 버퍼를 이용해 입출력을 처리합니다.

#### 11강 - 문자열

- 문자열은 컴퓨터 메모리 구조상에서 마지막에 널(NULL) 값을 포함한다.
- 널(NULL) 값은 문자열의 끝을 알리는 목적으로 사용
- 문자열과 포인터
  - **문자열** 형태로 **포인터**를 사용하면 포인터에 **특정한 문자열의 주소**를 넣게 됩니다.
  - "Hello World" 문자열을 읽기 전용으로 메모리 공간에 넣은 뒤에 그 위치를 처리한다.
  - 이러한 문자열을 '문자열 리터럴'이라고 말한다. 이는 컴파일러가 알아서 메모리 주소를 결정한다.
  - 포인터로 문자열을 선언했다고 하더라도 기존의 배열처럼 처리할 수 있다.
- 문자열 입출력 함수
  - scanf() 함수는 공백을 만날 때까지 입력받지만 **gets() 함수**는 **공백까지 포함하여 한줄**을 입력받는다.
  - gets() 함수는 버퍼의 크기를 벗어나도 입력을 받아버린다.
  - C11 표준부터는 버퍼의 크기를 철저히 지키는 gets_s() 함수가 추가되었다.
  - gets_s()를 이용하는 경우 범위를 넘으면 그 즉시 런타임(Runtime) 오류가 발생하게 된다.
- C언어의 문자열처리 관련해서는 기본적인 문자열 함수를 알고 있는 것이 좋다.
- 나중에 C++을 이용하면 더욱 간편하고 다양한 함수를 사용할 수 있다.
- C언어에서의 문자열 함수는 <string.h> 라이브러리에 포함되어 있다.
- strlen()는 문자열의 길이를 반환한다.
- strcmp()는 문자열 1이 문자열 2보다 사전적으로 앞에 있으면 -1, 뒤에 있으면 1을 반환한다.
- strcpy()는 문자열을 복사한다.
- **C언어에서는 기본적으로 'a=b'와 같은 간단한 방식으로는 문자열 복사 안된다.**
- strcat()은 뒤에 있는 문자열을 앞에 있는 문자열에 합친다.
- strstr()은 긴 문자열에서 짧은 문자열을 찾아 그 위치를 반환한다.
- 짧은 문자열을 찾은 주소 값 자체를 반환하므로 단순히 출력하도록 하면, 찾은 이후 모든 문자열이 반환된다.

> 2019-03-08

#### 12강 - 컴퓨터가 변수를 처리하는 방법

프로그램 메모리 주소

- 컴퓨터에서 프로그램이 실행되기 위해서는 프로그램이 메모리에 적재(Load) 되야 한다.
- 당연히 프로그램의 크기를 충당할 수 있을 만큼의 공간이 있어야 한다.
- 일반적인 컴퓨터의 운영체제는 메모리 공간을 네가지로 구분하여 관리한다.
  **코드 영역**(소스코드), **데이터 영역**(전역변수/정적변수), **힙 영역**(동적 할당 변수), **스택 영역**(지역 변수/매개변수)

**전역변수**란 프로그램의 어디서든 접근 가능한 변수

- main 함수가 실행되기도 전에 프로그램의 시작과 동시에 메모리에 할당
- 프로그램의 크기가 커질 수록 전역 변수로 인해 프로그램이 복잡해질 수 있음
- 메모리의 **데이터(Data) 영역**에 적재

**지역변수**란 프로그램에서 특정한 블록에서만 접근할 수 있는 변수

- 함수가 실행될 때마다 메모리에 할당되어 함수가 종료되면 메모리에서 해제된다.
- 메모리의 **스택(Stack) 영역**에 기록

**정적변수(Static Variable)**란 특정한 블록에서만 접근할 수 있는 변수  / 지역변수와 전역변수의 특징 모두 가짐

- 프로그램이 실행될 때 메모리에 할당되어 프로그램이 종료되면 메모리에서 해제된다.
- 메모리 **데이터(Data) 영역**에 적재

**레지스터 변수** 

- 레지스터 변수(Register Variable)란 메인 메모리 대신 CPU의 레지스터를 사용하는 변수
- 레지스터는 매우 한정되어 있으므로 실제로 레지스터에서 처리될지는 장담할 수 없다. 
- 더 빠르게 처리되리라 기대할 수 있다.

함수의 매개변수가 처리될 때

- 함수를 호출할 때 함수에 필요한 데이터를 매개변수로 전달한다.
- 전달 방식은 <값에 의한 전달> 방식과 <참조에 의한 전달> 방식이 있다.
- **값에 의한 전달 방식**은 단지 **값을 전달**하므로 함수 내에서 **변수가 새롭게 생성**된다.
- **참조에 의한 전달 방식**은 **주소를 전달**하므로 **원래의 변수 자체에 접근**할 수 있다. 
  - 참조에 의한 전달 방식은 단지 매개변수로 '포인터(Pointer)' 변수를 보낼 뿐 딱히 특별한 게 아니다. 

#### 13강 - 다차원 배열과 포인터 배열

2차원 배열의 초기화

- 2차원 배열은 1차원 배열이 중첩되었다는 의미로 [] (대괄호) 두번 연속해서 쓴다
  기본적으로 행이 먼저 들어간다.

  ```c
  int a[3][3] = { {1,2,3}, {4,5,6},{7,8,9}};
  ```

포인터 배열의 구조 분석

- 배열은 포인터와 동일한 방식으로 동작
- 배열의 이름은 배열의 원소의 첫번째 주소가 된다
- 유일한 차이점이라고 하면, 포인터는 변수이며 배열의 이름 상수이다.
- 포인터는 연산을 통해 자료형의 크기만큼 이동한다.
  - 따라서 정수(int)형 포인터는 4바이트(Bytes)씩 이동한다.

#### 14강 - 동적 메모리 할당

- 일반적으로 C언어에서 배열의 경우 사전에 적절한 크기만큼 할당해주어야 한다.
- 우리가 원하는 만큼만 메모리를 할당해서 사용하고자 한다면 동적 메모리 할당을 사용한다.
- 동적이라는 말의 의미는 '프로그램 실행 도중에'라는 의미

동적 메모리 할당 함수

- C언어에서는 malloc() 함수를 이용해 원하는 만큼의 메모리 공간을 확보 할 수 있다.

- malloc() 함수는 메모리 할당에 성공하면 주소를 반환하고, 그렇지 않으면 NULL을 반환한다.

- malloc() 함수는 <stdlib.h> 라이브러리에 정의되어 있다.

  ```c
  malloc(할당할 바이트 크기);
  ```

- 동적으로 할당된 변수는 <힙 영역>에 저장된다.

- 전통적인 C언어에서는 스택에 선언된 변수는 따로 메모리 해제를 해주지 않아도 된다.

- 반면에 **동적으로 할당된 변수는 반드시 free() 함수**로 **메모리 해제**를 해주어야 한다.

- 메모리 해제를 하지 않으면 메모리 내의 프로세스 무게가 더해져 언젠가는 오류가 발생한다.

- 메모리 누수(Memory Leak) 방지는 코어 개발자의 핵심 역량이다.

동적으로 문자열 처리하기

- 일괄적인 범위의 메모리를 모두 특정한 값으로 설정하기 위해서는 memset()을 사용한다.
- memset(포인터, 값, 크기);
- 한 바이트 씩 값을 저장하므로 문자열 배열의 처리 방식과 흡사하다.
- 따라서 memset() 함수는 <string.h> 라이브러리에 선언되어 있다.

> 2019-03-11

#### 15강 - 함수 포인터

- C언어에서는 함수의 이름을 이용해 특정한 함수를 호출한다.
- 함수 이름은 메모리 주소를 반환한다.

- 함수 포인터는 특정한 함수의 반환 자료형을 지정하는 방식으로 선언할 수 있다.

- 함수 포인터를 이용하면 형태가 같은 서로 다른 기능의 함수를 선택적으로 사용할 수 있습니다.

- ```
  반환 자료형(*이름)(매개별수) = 함수명;
  ```

- ```c
  #include <stdio.h>
  
  void myFunction(){
      printf("It's my function");
  }
  
  void yourFunction(){
      printf("It's your function");
  }
  
  int main(void){
      void(*fp)() = myFunction;
      fp();
      fp = yourFunction;
      fp();
      system("pause");
      return 0;
  }
  ```

- 함수 포인터를 반환하여 사용하기

  ```c
  #include <stdio.h>
  
  int add(int a, int b){
      return a + b;
  }
  
  int(*process(char* a))(int, int){
      printf("%s\n", a);
      return add;
  }
  
  int main(void){
      int(*fp)(int, int) = add;
      printf("%d\n", fp(10, 30));
      fp = sub;
      printf("%d\n", process("10 + 20 = ?")(10, 20));
      system("pause");
      return 0;
  }
  ```

  - 잘 안쓴다. 필요할 때 구글링. 

#### 16강 - 구조체

- 여러개의 변수를 묶어 **하나의 객체**를 표현하고자 할 때 구조체를 사용할 수 있다.

- 캐릭터, 몬스터, 학생, 좌표 등 다양한 객체를 모두 프로그래밍 언어를 이용해 표현할 수 있다.

- ```c
  struct 구조체명{
      자료형1 변수명1;
      자료형2 변수명2;
  }
  ```

- ```c
  struct Student{
      char studentId[10];
      char name[10];
      int grade;
      int major;
  }
  ```

- 구조체의 변수의 선언과 접근

  - 기본적으로 구조체의 변수에 접근할 때는 온점(.)을 사용한다.

    ```c
    struct Student s; //구조체 변수 선언
    strcpy(s.studentId, "00000000"); //구조체 변수에 접근
    strcpy(s.name, "ooo");
    s.grade = 4;
    strcpy(s.major, "OOO OOO");
    ```

- 구조체의 정의와 선언

  - 하나의 구조체 변수만 사용하는 경우 정의와 동시에 선언을 할 수도 있다.

  - 이 경우 변수는 전역 변수로 사용된다.

    ```c
    struct Student{ // 학생 구조체 정의 및 선언
      char studentId[10];
      char name[10];
      int grade;
      char major[51];  
    } s;
    ```

- 구조체의 초기화

  - 구조체의 변수를 한 번에 초기화하기 위해서는 중괄호에 차례대로 변수의 값을 넣는다.

    ```c
    struct Student s = {"000000", "OOO", 1, "OOOOOO"};
    ```

- 더 짧게 구조체 정의하기

  - typedef 키워드를 이용하면 임의의 자료형을 만들 수 있으므로 선언이 더 짧아진다.

    ```c
    typedef struct Student{
        char studentId[10];
        ...
    } Student;
    ```

  - 최근에는 익명 구조체의 개념이 등장하여, 구조체 이름 부분을 비워놔도 된다.

    ```c
    typedef struct{ //학생 구조체 정의
        ...
    } Student
    ```

- 구조체 포인터 변수에 접근하기

  - 구조체가 포인터 변수로 사용되는 경우 변수에 접근할 때 화살표 (->)를 사용합니다.

    ```c
    int main(void){
        Student *s = malloc(sizeof(Student));
        
        printf("학번: %s\n", s->studentId);
        printf("이름: %s\n", s->name);
        system("pause");
        return 0;
    }
    ```

#### 17강 - 파일 입출력

- 프로그램이 꺼진 이후에도 데이터를 저장하기 위해서는 파일 입출력이 필요
- 파일을 열고 닫기
  - 파일 입출력 변수는 FILE 형식의 포인터 변수로 선언합니다.
  - 파일을 열 떄는 fopen() 함수를 이용합니다.
    - 파일경로와 접근 방식을 설정할 수 있습니다. 
    - r : 읽기, w : 쓰기, a : 접근하여 데이터를 뒤에서부터 기록
  - 파일을 닫을 때는 fclose() 함수를 이용합니다.

- 파일 입출력 함수

  - 기본적인 입출력을 위해서 printf()와 scanf() 함수를 사용하곤 했습니다.
  - 파일 입출력에서는 그 대신에 fprintf()와 fscanf()가 사용된다.
    fprintf(파일 포인터, 서식, 형식지정자);
    fscanf(파일 포인터, 서식, 형식지정자);

- 파일 입출력의 과정

  - 파일 입출력은 열고, 읽고/쓰고, 닫기의 과정을 철저히 따라야 한다.
  - 파일을 열 때는 파일 포인터가 사용되며, 이는 동적으로 할당된 것
  - 따라서 파일 처리 이후에 파일을 닫아주지 않으면 메모리 누수가 발생

- ```c
  #define _CRT_SECURE_NO_WARNINGS
  #include <stdio.h>
  
  int main(void){
      char s[20] = "Hello World";
      FILE *fp;
      fp = fopen("temp.txt", "w");
      fprintf(fp, "%s\n", s);
      fclose(fp);
      return 0;
  }
  ```









